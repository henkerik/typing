imports 
{
import CCO.Tree             (ATerm (App), Tree (fromTree, toTree))
import CCO.Tree.Parser      (parseTree, app, arg)
import Control.Applicative  (Applicative ((<*>)), (<$>), pure)
import Prelude              hiding (sequence)
import MF.Languages.PHP.Types
}

-------------------------------------------------------------------------------
-- Document
-------------------------------------------------------------------------------

data OptionalString
    | Some value :: {String}
    | None

deriving OptionalString: Show
deriving OptionalString: Eq
deriving OptionalString: Ord


type ParamList = [Node]

data Node
    -- Document
    | Document before :: {[Node]} open :: Node stmt :: Node close :: Node after :: {[Node]}
    | OpenTag
    | CloseTag
    
    -- InlineHTML
    | Literal value :: String
    
    -- Statement
    | While c :: Node s :: Node
    | If c :: Node l :: Node elseIfs :: {[Node]} r :: Node
    | Block s :: Node
    | Expr e :: Node
    | Sequence f :: Node s :: Node
    | Skip
    | Return e :: Node
    
    -- ElseIfStatement        
    | ElseIf e :: Node s :: Node
   
    -- Expr
    | Assign  rv :: Node e :: Node
    --| LNumber ln  :: Node
    | LTrue
    | LFalse
    
    -- Arithmetic
    | Plus l :: Node r :: Node
    | Min l :: Node r :: Node
    | Mul l :: Node r :: Node
    | Mod l :: Node r :: Node
    
    -- Compare
    | IsEqual l :: Node r :: Node
    
    -- Logical
    | Or l :: Node r :: Node
    
    | FunctionCall name :: Node params :: ParamList
    | FunctionName value :: String
    

    -- Strings
    | ConstantEncapsedString n :: Node
    | DoubleQuoted n :: Node
    | DQContent value :: OptionalString
    | String value :: String                    -- The Simplify AG turns every qouted character sequences into a String node 
    
    -- Introduced by the simplifier: result = name (params)
    | SimplifiedFunctionCall name :: String params :: ParamList result :: {Maybe Node}
    
    -- ReferenceVariable
    | Variable n :: Node
    | ArrayAccess rv :: Node index :: Node
    
    -- VariableName
    | Simple value :: String
    
    -- LNumber
    | Deci value :: Integer
    
    -- FunctionDecl
    | FunctionDecl name :: String params :: ParamList stmt :: Node

    
    -- Params 
    | Param e :: Node



    -- Additional: Special node for type check, used for unit testing, not part of the language. Check nodes are generated by the Simplify AG
    | Expect expr :: Node ty :: {TypeSet}
    
    
    
deriving Node: Show
deriving Node: Eq
deriving Node: Ord

{

sequence :: [Node] -> Node
sequence []     = Skip
sequence [x]    = x
sequence xs     = foldr Sequence (last xs) (L.init xs)


buildDocument before open stmts = Document before open (sequence stmts)


instance Tree OptionalString where
    fromTree = undefined
    toTree = parseTree [ app "Some" (Some <$> arg), app "None" (pure None)]


instance Tree Node where
    fromTree = undefined    
    toTree = parseTree [ -- Document
                         app "Document"      (buildDocument <$> arg <*> arg <*> arg <*> arg <*> arg)
                         
                         --  Open
                       , app "ShortOpenTag"  (pure OpenTag)
                       , app "FullOpenTag"   (pure OpenTag)
                       , app "ASPOpenTag"    (pure OpenTag)
                       
                         -- Close
                       , app "CloseTag"      (pure CloseTag)
                       , app "ASPCloseTag"   (pure CloseTag)
                       
                         -- InlineHTML
                       , app "Literal"       (Literal <$> arg)
                       
                         -- Statement
                       , app "Expr"          (Expr <$> arg)
                       , app "While"         (While <$> arg <*> arg)
                       , app "Block"         (sequence <$> arg)
                       , app "If"            (If <$> arg <*> arg <*> arg <*> arg)
                       , app "Return"        (Return <$> arg)
                       
                         -- ElseIfStatement
                       , app "ElseIf"        (ElseIf <$> arg <*> arg)
    
                         -- Expression
                       , app "Assign"        (Assign <$> arg <*> arg)
                       , app "LNumber"       (id <$> arg)
                       , app "True"          (pure LTrue)
                       , app "False"         (pure LFalse)
                       
                       , app "Plus"          (Plus <$> arg <*> arg)
                       , app "Min"           (Min <$> arg <*> arg)
                       , app "Mul"           (Mul <$> arg <*> arg)
                       , app "Mod"           (Mod <$> arg <*> arg)
                       
                       , app "IsEqual"       (IsEqual <$> arg <*> arg)
                       , app "Or"            (Or <$> arg <*> arg)
                       , app "FunctionCall"  (buildFunctionCall <$> arg <*> arg)
                       
                         -- FunctionName 
                       , app "FunctionName"  (FunctionName <$> arg)
                       
                       
                         -- Strings
                       , app "ConstantEncapsedString" (id <$> arg)
                       , app "DoubleQuoted"  (id <$> arg)
                       , app "DQContent"     (DQContent <$> arg)
                       
                       
                         -- ReferenceVariable
                       , app "ArrayAccess"   (ArrayAccess <$> arg <*> arg)
                       
                         -- CompoundVariable
                       , app "Variable"      (Variable <$> arg)
                       
                         -- This is the ? in the grammar
                       , app "Some"          (id <$> arg)
                       , app "None"          (pure Skip)
                       
                         -- SimpleVariableName
                       , app "Simple"        (Simple <$> arg)
                       
                       -- LNumber
                       , app "Deci"          ((\value -> Deci $ read value) <$> arg)
                       
                       -- FunctionDecl
                       , app "FunctionDecl"  (buildFunctionDecl <$> arg <*> arg <*> arg)

                       -- Params 
                       , app "Param"         (Param <$> arg)
                       ]

buildFunctionDecl name params stmt = FunctionDecl name params (sequence stmt)
buildFunctionCall name params      = FunctionCall name params -- (sequence params)

}
