imports
{
import qualified MF.Flowable as F
import MF.Flowable hiding (Return)
import Data.IntMap as IM
import Data.Map as M
import Data.Maybe
import Control.Applicative
}

-------------------------------------------------------------------------------
-- Labels & Nodes
-------------------------------------------------------------------------------

attr Node ParamList
    inh labels :: {Label}
    syn labels :: {Label}

    syn label  :: {Label}  
--    syn label' :: {Label}

  
attr Node
    syn nodes use {`IM.union`} {IM.empty} :: {IntMap Node}

sem Node
    | If While Skip Assign Sequence Simple Deci Variable LTrue LFalse Plus Min Mul Mod ArrayAccess Return IsEqual Or Expect Return FunctionCall Param String Expr
        loc.label :: uniqueref labels
        lhs.label = @loc.label
        +nodes    = IM.union $ IM.singleton @label @self
        
    | FunctionDecl
        loc.ln :: uniqueref labels  -- Entry
        loc.lx :: uniqueref labels  -- Exit
        +nodes    = IM.union $ IM.singleton @label @self
        
    | SimplifiedFunctionCall
        loc.lb :: uniqueref labels  -- Before
        loc.lc :: uniqueref labels  -- Call
        loc.lr :: uniqueref labels  -- Return
        loc.la :: uniqueref labels  -- After
        +nodes    = IM.union $ IM.singleton @label @self


-------------------------------------------------------------------------------
-- Init
-------------------------------------------------------------------------------
       
attr Node
  syn init :: {Maybe Label}

sem Node
    | Document 
        lhs.init = @stmt.init
    | SimplifiedFunctionCall
        lhs.init = Just @lb
    | If While Skip Expr Expect Return
        lhs.init = Just @label
    | Sequence 
        lhs.init = @f.init <|> @s.init
    | Block
        lhs.init = @s.init
    | FunctionDecl
        lhs.init = Nothing
        
        
-------------------------------------------------------------------------------
-- Final
-------------------------------------------------------------------------------

attr Node
  syn final :: {Maybe [Label]}

sem Node
    | Document 
        lhs.final = @stmt.final 
    | SimplifiedFunctionCall
        lhs.final = Just [@la]
    | Expr While Skip Expect Return 
        lhs.final = Just [@label]
    | Sequence 
        lhs.final = @s.final <|> @f.final
    | If 
        lhs.final = pure (++) <*> @l.final <*> @r.final
    | Block 
        lhs.final = @s.final
    | FunctionDecl
        lhs.final = Nothing
        
                             
-------------------------------------------------------------------------------
-- Flow
-------------------------------------------------------------------------------


attr Node
  syn flow use {++} {[]} :: {Flow}

sem Node
    | Sequence 
        +flow = (++) $ if isNothing @s.init || isNothing @f.final then [] else [(l, fromJust @s.init) | l <- fromJust @f.final]
    | If 
        +flow = (++) $ [(@label, fromJust @l.init), (@label, fromJust @r.init)]
    | While 
        +flow = (++) $ [(@label, fromJust @s.init)] ++ [(l', @label) | l' <- fromJust @s.final]
    | Return
        +flow = (++) $ [(@label, lx @lhs.declaration)]
    | FunctionDecl
        +flow = (++) $ [(@ln, fromJust @stmt.init)]
    | SimplifiedFunctionCall
        +flow = let (Declaration name ln lx) = lookupDeclaration @name @lhs.declarations'
                in (++) [(@lb, @la), (@lb, @lc), (@lr, @la), (@lc, ln), (lx, @lr)]

{
lookupDeclaration name declarations = case M.lookup name declarations of 
                                          Nothing   -> error $ "Calling an undefined function: " ++ name
                                          Just info -> info
}

-------------------------------------------------------------------------------
-- Function Declarations
-------------------------------------------------------------------------------

{
data Declaration = Declaration { functionName :: String, ln :: Label, lx :: Label }
}

attr Node 
    syn declarations use {`M.union`} {M.empty} :: {Map String Declaration}
    inh declarations'                          :: {Map String Declaration}
    
    inh declaration :: {Declaration}
    
sem Node
    | Document
        stmt.declarations' = @stmt.declarations
    | FunctionDecl
        loc.declaration = Declaration @name @ln @lx
        stmt.declaration = @loc.declaration
        +declarations   = M.union $ M.singleton @name @loc.declaration

-------------------------------------------------------------------------------
-- Transfer
-------------------------------------------------------------------------------
        
attr Node
    syn blocks use {`IM.union`} {IM.empty} :: {IntMap (Block Node)}

sem Node
    | Skip Expect Expr While If Return
        +blocks = IM.union $ IM.singleton @label $ Normal @self
    | SimplifiedFunctionCall
        +blocks = IM.union $ IM.fromList [(@lb, Normal Skip)
                                 ,(@lc, Call @lc @lr @self)
                                 ,(@lr, F.Return @lc @lr @self)
                                 ,(@la, Normal Skip)]
    | FunctionDecl 
        +blocks = IM.union $ IM.fromList [(@ln, Entry @self)
                                 ,(@lx, Exit @self)]

-------------------------------------------------------------------------------
-- Blocks
-------------------------------------------------------------------------------


attr Node OptionalString ParamList
    syn copy :: SELF

{-
attr Node
    syn blocks use {`IM.union`} {IM.empty} :: {IntMap (F.Block Node)}

sem Node 
    | Skip Expr If While Expect Return
        +blocks = IM.union $ IM.singleton @label (F.Normal @copy)
    | SimplifiedFunctionCall
        +blocks = IM.union $ IM.fromList [(@lc, F.Call @copy), (@lr, F.Return @copy), (@lb, F.Normal Skip), (@la, F.Normal Skip)]
    | FunctionDecl
        +blocks = IM.union $ IM.fromList [(@ln, F.Entry @copy), (@lx, F.Exit @copy)]
-}        


-------------------------------------------------------------------------------
-- Nodes
-------------------------------------------------------------------------------
{-
attr Node 
    syn nodes use {`IM.union`} {IM.empty} :: {IntMap Node}

sem Node
    | Expect 
        loc.nodes = IM.singleton @label @expr.copy `IM.union` @expr.nodes
    | Assign Return Expr
        loc.nodes = IM.singleton @label @copy `IM.union` @e.nodes
        lhs.nodes = @loc.nodes
    | If While 
        loc.nodes = @c.nodes
    | Plus Variable Or
        +nodes = IM.union $ IM.singleton @label @copy
-}      

{

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

-- 'Execute' the AG, TODO: move to AG.ag
execute p = wrap_Node (sem_Node p) inh
    where
        inh = Inh_Node { labels_Inh_Node = 0 }   

-- Make Node an instance of Flowable, in this way it can be consumed by a monotome framework
instance Flowable Node where
    init     = fromJust . init_Syn_Node . execute
    final    = fromJust . final_Syn_Node . execute
    flow     = flow_Syn_Node . execute
    nodes    = nodes_Syn_Node . execute
    blocks   = IM.map (\block f -> f block) . blocks_Syn_Node . execute  

}
